/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { Subject } from 'rxjs';
/**
 * Notifier queue service
 *
 * In general, API calls don't get processed right away. Instead, we have to queue them up in order to prevent simultanious API calls
 * interfering with each other. This, at least in theory, is possible at any time. In particular, animations - which potentially overlap -
 * can cause changes in JS classes as well as affect the DOM. Therefore, the queue service takes all actions, puts them in a queue, and
 * processes them at the right time (which is when the previous action has been processed successfully).
 *
 * Technical sidenote:
 * An action looks pretty similar to the ones within the Flux / Redux pattern.
 */
import * as ɵngcc0 from '@angular/core';
var NotifierQueueService = /** @class */ (function () {
    /**
     * Constructor
     */
    function NotifierQueueService() {
        this.actionStream = new Subject();
        this.actionQueue = [];
        this.isActionInProgress = false;
    }
    /**
     * Push a new action to the queue, and try to run it
     *
     * @param action Action object
     */
    /**
     * Push a new action to the queue, and try to run it
     *
     * @param {?} action Action object
     * @return {?}
     */
    NotifierQueueService.prototype.push = /**
     * Push a new action to the queue, and try to run it
     *
     * @param {?} action Action object
     * @return {?}
     */
    function (action) {
        this.actionQueue.push(action);
        this.tryToRunNextAction();
    };
    /**
     * Continue with the next action (called when the current action is finished)
     */
    /**
     * Continue with the next action (called when the current action is finished)
     * @return {?}
     */
    NotifierQueueService.prototype.continue = /**
     * Continue with the next action (called when the current action is finished)
     * @return {?}
     */
    function () {
        this.isActionInProgress = false;
        this.tryToRunNextAction();
    };
    /**
     * Try to run the next action in the queue; we skip if there already is some action in progress, or if there is no action left
     */
    /**
     * Try to run the next action in the queue; we skip if there already is some action in progress, or if there is no action left
     * @private
     * @return {?}
     */
    NotifierQueueService.prototype.tryToRunNextAction = /**
     * Try to run the next action in the queue; we skip if there already is some action in progress, or if there is no action left
     * @private
     * @return {?}
     */
    function () {
        if (this.isActionInProgress || this.actionQueue.length === 0) {
            return; // Skip (the queue can now go drink a coffee as it has nothing to do anymore)
        }
        this.isActionInProgress = true;
        this.actionStream.next(this.actionQueue.shift()); // Push next action to the stream, and remove the current action from the queue
    };
    /** @nocollapse */
    NotifierQueueService.ctorParameters = function () { return []; };
NotifierQueueService.ɵfac = function NotifierQueueService_Factory(t) { return new (t || NotifierQueueService)(); };
NotifierQueueService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NotifierQueueService, factory: function (t) { return NotifierQueueService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NotifierQueueService, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return NotifierQueueService;
}());
export { NotifierQueueService };
if (false) {
    /**
     * Stream of actions, subscribable from outside
     * @type {?}
     */
    NotifierQueueService.prototype.actionStream;
    /**
     * Queue of actions
     * @type {?}
     * @private
     */
    NotifierQueueService.prototype.actionQueue;
    /**
     * Flag, true if some action is currently in progress
     * @type {?}
     * @private
     */
    NotifierQueueService.prototype.isActionInProgress;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm90aWZpZXItcXVldWUuc2VydmljZS5qcyIsInNvdXJjZXMiOlsibmc6L2FuZ3VsYXItbm90aWZpZXIvbGliL3NlcnZpY2VzL25vdGlmaWVyLXF1ZXVlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFM0MsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQjtBQUNHO0FBQTBCO0FBQUc7QUFLa0M7QUFDSztBQUNIO0FBQy9CO0FBQUc7QUFBdUI7QUFHcEQ7O0FBRVg7QUFJQSxJQWNDO0FBQ0Q7QUFDRyxPQUFDO0FBQ0osSUFBQztBQUNVLFFBQVQsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLE9BQU8sRUFBa0IsQ0FBQztBQUNwRCxRQUFFLElBQUksQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDO0FBQ3hCLFFBQUUsSUFBSSxDQUFDLGtCQUFrQixHQUFHLEtBQUssQ0FBQztBQUNsQyxJQUFDLENBQUM7QUFDRixJQUNDO0FBQ0Q7QUFDRztBQUNHO0FBRUYsT0FEQTtBQUNKO0FBQVE7QUFDVTtBQUFPO0FBRXpCO0FBR1U7QUFBUSxJQU5WLG1DQUFJO0FBQU87QUFDVTtBQUM1QjtBQUlDO0FBQW1CO0FBQVEsSUFONUIsVUFBYSxNQUFzQjtBQUFJLFFBQ3RDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFFLE1BQU0sQ0FBRSxDQUFDO0FBQ2xDLFFBQUUsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7QUFDNUIsSUFBQyxDQUFDO0FBRUYsSUFBQztBQUNEO0FBQ0csT0FBQztBQUNKO0FBQVE7QUFFb0I7QUFJbkI7QUFBUSxJQU5ULHVDQUFRO0FBQU87QUFNbEI7QUFBbUI7QUFBUSxJQU4vQjtBQUFjLFFBQ2IsSUFBSSxDQUFDLGtCQUFrQixHQUFHLEtBQUssQ0FBQztBQUNsQyxRQUFFLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO0FBQzVCLElBQUMsQ0FBQztBQUVGLElBQUM7QUFDRDtBQUNHLE9BQUM7QUFDSjtBQUFRO0FBRXlCO0FBQWdCO0FBQW1CO0FBQVEsSUFGbkUsaURBQWtCO0FBQU87QUFFeUI7QUFBZ0I7QUFFMUU7QUFBUSxJQUpSO0FBQWMsUUFDYixJQUFLLElBQUksQ0FBQyxrQkFBa0IsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUc7QUFDbEUsWUFBRyxPQUFPLENBQUMsNkVBQTZFO0FBQ3hGLFNBQUc7QUFDSCxRQUFFLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUM7QUFDakMsUUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBRSxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxDQUFFLENBQUMsQ0FBQywrRUFBK0U7QUFDckksSUFBQyxDQUFDLENBckRJO0FBQUM7aUNBRE4sVUFBVSwzQ0FDbUI7Ozs7O2dEQUszQjtBQUFDLElBa0RKLDJCQUFDO0FBQ0EsQ0FEQSxBQXhERCxJQXdEQztBQUNELFNBeERhLG9CQUFvQjtBQUVqQztBQUNRO0FBQVE7QUFFRjtBQUFpQjtBQUFRLElBQXRDLDRDQUFzRDtBQUN2RDtBQUVFO0FBRUY7QUFBaUI7QUFBZ0I7QUFBUSxJQUF4QywyQ0FBMkM7QUFDNUM7QUFFRTtBQUVGO0FBQWlCO0FBQWdCO0FBRS9CLElBRkQsa0RBQW9DO0FBQ3JDO0FBQ0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgTm90aWZpZXJBY3Rpb24gfSBmcm9tICcuLi9tb2RlbHMvbm90aWZpZXItYWN0aW9uLm1vZGVsJztcblxuLyoqXG4gKiBOb3RpZmllciBxdWV1ZSBzZXJ2aWNlXG4gKlxuICogSW4gZ2VuZXJhbCwgQVBJIGNhbGxzIGRvbid0IGdldCBwcm9jZXNzZWQgcmlnaHQgYXdheS4gSW5zdGVhZCwgd2UgaGF2ZSB0byBxdWV1ZSB0aGVtIHVwIGluIG9yZGVyIHRvIHByZXZlbnQgc2ltdWx0YW5pb3VzIEFQSSBjYWxsc1xuICogaW50ZXJmZXJpbmcgd2l0aCBlYWNoIG90aGVyLiBUaGlzLCBhdCBsZWFzdCBpbiB0aGVvcnksIGlzIHBvc3NpYmxlIGF0IGFueSB0aW1lLiBJbiBwYXJ0aWN1bGFyLCBhbmltYXRpb25zIC0gd2hpY2ggcG90ZW50aWFsbHkgb3ZlcmxhcCAtXG4gKiBjYW4gY2F1c2UgY2hhbmdlcyBpbiBKUyBjbGFzc2VzIGFzIHdlbGwgYXMgYWZmZWN0IHRoZSBET00uIFRoZXJlZm9yZSwgdGhlIHF1ZXVlIHNlcnZpY2UgdGFrZXMgYWxsIGFjdGlvbnMsIHB1dHMgdGhlbSBpbiBhIHF1ZXVlLCBhbmRcbiAqIHByb2Nlc3NlcyB0aGVtIGF0IHRoZSByaWdodCB0aW1lICh3aGljaCBpcyB3aGVuIHRoZSBwcmV2aW91cyBhY3Rpb24gaGFzIGJlZW4gcHJvY2Vzc2VkIHN1Y2Nlc3NmdWxseSkuXG4gKlxuICogVGVjaG5pY2FsIHNpZGVub3RlOlxuICogQW4gYWN0aW9uIGxvb2tzIHByZXR0eSBzaW1pbGFyIHRvIHRoZSBvbmVzIHdpdGhpbiB0aGUgRmx1eCAvIFJlZHV4IHBhdHRlcm4uXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOb3RpZmllclF1ZXVlU2VydmljZSB7XG5cblx0LyoqXG5cdCAqIFN0cmVhbSBvZiBhY3Rpb25zLCBzdWJzY3JpYmFibGUgZnJvbSBvdXRzaWRlXG5cdCAqL1xuXHRwdWJsaWMgcmVhZG9ubHkgYWN0aW9uU3RyZWFtOiBTdWJqZWN0PE5vdGlmaWVyQWN0aW9uPjtcblxuXHQvKipcblx0ICogUXVldWUgb2YgYWN0aW9uc1xuXHQgKi9cblx0cHJpdmF0ZSBhY3Rpb25RdWV1ZTogQXJyYXk8Tm90aWZpZXJBY3Rpb24+O1xuXG5cdC8qKlxuXHQgKiBGbGFnLCB0cnVlIGlmIHNvbWUgYWN0aW9uIGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzc1xuXHQgKi9cblx0cHJpdmF0ZSBpc0FjdGlvbkluUHJvZ3Jlc3M6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdG9yXG5cdCAqL1xuXHRwdWJsaWMgY29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5hY3Rpb25TdHJlYW0gPSBuZXcgU3ViamVjdDxOb3RpZmllckFjdGlvbj4oKTtcblx0XHR0aGlzLmFjdGlvblF1ZXVlID0gW107XG5cdFx0dGhpcy5pc0FjdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQdXNoIGEgbmV3IGFjdGlvbiB0byB0aGUgcXVldWUsIGFuZCB0cnkgdG8gcnVuIGl0XG5cdCAqXG5cdCAqIEBwYXJhbSBhY3Rpb24gQWN0aW9uIG9iamVjdFxuXHQgKi9cblx0cHVibGljIHB1c2goIGFjdGlvbjogTm90aWZpZXJBY3Rpb24gKTogdm9pZCB7XG5cdFx0dGhpcy5hY3Rpb25RdWV1ZS5wdXNoKCBhY3Rpb24gKTtcblx0XHR0aGlzLnRyeVRvUnVuTmV4dEFjdGlvbigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnRpbnVlIHdpdGggdGhlIG5leHQgYWN0aW9uIChjYWxsZWQgd2hlbiB0aGUgY3VycmVudCBhY3Rpb24gaXMgZmluaXNoZWQpXG5cdCAqL1xuXHRwdWJsaWMgY29udGludWUoKTogdm9pZCB7XG5cdFx0dGhpcy5pc0FjdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHR0aGlzLnRyeVRvUnVuTmV4dEFjdGlvbigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyeSB0byBydW4gdGhlIG5leHQgYWN0aW9uIGluIHRoZSBxdWV1ZTsgd2Ugc2tpcCBpZiB0aGVyZSBhbHJlYWR5IGlzIHNvbWUgYWN0aW9uIGluIHByb2dyZXNzLCBvciBpZiB0aGVyZSBpcyBubyBhY3Rpb24gbGVmdFxuXHQgKi9cblx0cHJpdmF0ZSB0cnlUb1J1bk5leHRBY3Rpb24oKTogdm9pZCB7XG5cdFx0aWYgKCB0aGlzLmlzQWN0aW9uSW5Qcm9ncmVzcyB8fCB0aGlzLmFjdGlvblF1ZXVlLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdHJldHVybjsgLy8gU2tpcCAodGhlIHF1ZXVlIGNhbiBub3cgZ28gZHJpbmsgYSBjb2ZmZWUgYXMgaXQgaGFzIG5vdGhpbmcgdG8gZG8gYW55bW9yZSlcblx0XHR9XG5cdFx0dGhpcy5pc0FjdGlvbkluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRcdHRoaXMuYWN0aW9uU3RyZWFtLm5leHQoIHRoaXMuYWN0aW9uUXVldWUuc2hpZnQoKSApOyAvLyBQdXNoIG5leHQgYWN0aW9uIHRvIHRoZSBzdHJlYW0sIGFuZCByZW1vdmUgdGhlIGN1cnJlbnQgYWN0aW9uIGZyb20gdGhlIHF1ZXVlXG5cdH1cblxufVxuIl19