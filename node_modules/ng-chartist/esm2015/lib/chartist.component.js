/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, EventEmitter, Input, Output } from '@angular/core';
import * as Chartist from 'chartist';
/**
 * Represents chart events.
 * @record
 */
import * as ɵngcc0 from '@angular/core';
export function ChartEvent() { }
/**
 * Angular component which renders Chartist chart.
 *
 * See Chartist {\@link https://gionkunz.github.io/chartist-js/api-documentation.html API documentation} and
 * {\@link https://gionkunz.github.io/chartist-js/examples.html examples} for more information.
 * ### Example
 * ```html
 * <x-chartist
 * [type]="type"
 * [data]="data"
 * [options]="options"
 * [responsiveOptions]="responsiveOptions"
 * [events]="events"
 * ></x-chartist>
 * ```
 */
export class ChartistComponent {
    /**
     * @ignore
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        /**
         * Event emitted after Chartist chart has been initialized.
         *
         * Event handler function will receive chart instance argument.
         */
        this.initialized = new EventEmitter();
    }
    /**
     * @ignore
     * @return {?}
     */
    ngOnInit() {
        if (this.type && this.data) {
            this.renderChart();
        }
    }
    /**
     * @ignore
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.update(changes);
    }
    /**
     * @ignore
     * @return {?}
     */
    ngOnDestroy() {
        if (this.chart) {
            this.chart.detach();
            this.chart = null;
        }
    }
    /**
     * @ignore
     * @private
     * @return {?}
     */
    renderChart() {
        /** @type {?} */
        const nativeElement = this.elementRef.nativeElement;
        if (!(this.type in Chartist)) {
            throw new Error(`${this.type} is not a valid chart type`);
        }
        this.chart = ((/** @type {?} */ (Chartist)))[this.type](nativeElement, this.data, this.options, this.responsiveOptions);
        if (this.events) {
            this.bindEvents();
        }
        this.initialized.emit(this.chart);
    }
    /**
     * @ignore
     * @private
     * @param {?} changes
     * @return {?}
     */
    update(changes) {
        if (!this.type || !this.data) {
            return;
        }
        if (!this.chart || 'type' in changes) {
            this.renderChart();
        }
        else if (changes.data || changes.options) {
            ((/** @type {?} */ (this.chart))).update(this.data, this.options);
        }
    }
    /**
     * @ignore
     * @private
     * @return {?}
     */
    bindEvents() {
        for (const event of Object.keys(this.events)) {
            this.chart.on(event, this.events[event]);
        }
    }
}
ChartistComponent.ɵfac = function ChartistComponent_Factory(t) { return new (t || ChartistComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ChartistComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ChartistComponent, selectors: [["x-chartist"]], inputs: { data: "data", type: "type", options: "options", responsiveOptions: "responsiveOptions", events: "events" }, outputs: { initialized: "initialized" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 0, vars: 0, template: function ChartistComponent_Template(rf, ctx) { }, styles: ["[_nghost-%COMP%] {\n        display: block;\n      }"] });
/** @nocollapse */
ChartistComponent.ctorParameters = () => [
    { type: ElementRef }
];
ChartistComponent.propDecorators = {
    data: [{ type: Input }],
    type: [{ type: Input }],
    options: [{ type: Input }],
    responsiveOptions: [{ type: Input }],
    events: [{ type: Input }],
    initialized: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChartistComponent, [{
        type: Component,
        args: [{
                selector: 'x-chartist',
                template: '',
                styles: [`
      :host {
        display: block;
      }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { initialized: [{
            type: Output
        }], data: [{
            type: Input
        }], type: [{
            type: Input
        }], options: [{
            type: Input
        }], responsiveOptions: [{
            type: Input
        }], events: [{
            type: Input
        }] }); })();
if (false) {
    /**
     * The data object that needs to consist of a labels and a series array.
     * @type {?}
     */
    ChartistComponent.prototype.data;
    /**
     * Chartist chart type.
     * @type {?}
     */
    ChartistComponent.prototype.type;
    /**
     * The options object which overrides the default options.
     * @type {?}
     */
    ChartistComponent.prototype.options;
    /**
     * An array of responsive option arrays which are a media query and options object pair: [[mediaQueryString, optionsObject],[more...]]
     * @type {?}
     */
    ChartistComponent.prototype.responsiveOptions;
    /**
     * Events object where keys are Chartist event names and values are event handler functions.
     *
     * Supported events are: draw, optionsChanged, data, animationBegin, animationEnd, created.
     *
     * Event handler function will receive a data argument which contains event data.
     * @type {?}
     */
    ChartistComponent.prototype.events;
    /**
     * Event emitted after Chartist chart has been initialized.
     *
     * Event handler function will receive chart instance argument.
     * @type {?}
     */
    ChartistComponent.prototype.initialized;
    /**
     * @ignore
     * @type {?}
     * @private
     */
    ChartistComponent.prototype.chart;
    /**
     * @type {?}
     * @private
     */
    ChartistComponent.prototype.elementRef;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhcnRpc3QuY29tcG9uZW50LmpzIiwic291cmNlcyI6WyJuZzovbmctY2hhcnRpc3QvbGliL2NoYXJ0aXN0LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFJTCxNQUFNLEVBRVAsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxLQUFLLFFBQVEsTUFBTSxVQUFVLENBQUM7QUFDckM7QUFBSTtBQUE0QjtBQUFXOztBQXVCM0MsZ0NBRUM7QUFDRDtBQUNHO0FBQytDO0FBQ2hEO0FBRUY7QUFDQztBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFSDtBQUNHO0FBV0wsTUFBTSxPQUFPLGlCQUFpQjtBQUFHO0FBQVE7QUFBZTtBQUVsRDtBQUFRLElBNkNaLFlBQW9CLFVBQXNCO0FBQUksUUFBMUIsZUFBVSxHQUFWLFVBQVUsQ0FBWTtBQUFDO0FBRXRDO0FBR0o7QUFBVztBQUtrQjtBQUFZLFFBaEIxQyxnQkFBVyxHQUFHLElBQUksWUFBWSxFQUFtQixDQUFDO0FBQ3BELElBSytDLENBQUM7QUFDaEQ7QUFDTztBQUNGO0FBQ0Y7QUFBUSxJQURULFFBQVE7QUFBSyxRQUNYLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO0FBQ2hDLFlBQU0sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0FBQ3pCLFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDSDtBQUNPO0FBQ0Y7QUFBMEI7QUFDM0I7QUFBUSxJQURWLFdBQVcsQ0FBQyxPQUFzQjtBQUFJLFFBQ3BDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDekIsSUFBRSxDQUFDO0FBQ0g7QUFDTztBQUNGO0FBQ0w7QUFBUSxJQUROLFdBQVc7QUFBSyxRQUNkLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtBQUNwQixZQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDMUIsWUFBTSxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztBQUN4QixTQUFLO0FBQ0wsSUFBRSxDQUFDO0FBQ0g7QUFDTztBQUNGO0FBQWdCO0FBQ1A7QUFBUSxJQURaLFdBQVc7QUFDckI7QUFBeUIsY0FBZixhQUFhLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhO0FBQ3ZELFFBQ0ksSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxRQUFRLENBQUMsRUFBRTtBQUNsQyxZQUFNLE1BQU0sSUFBSSxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSw0QkFBNEIsQ0FBQyxDQUFDO0FBQ2hFLFNBQUs7QUFDTCxRQUNJLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxtQkFBSyxRQUFRLEVBQUEsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FDckMsYUFBYSxFQUNiLElBQUksQ0FBQyxJQUFJLEVBQ1QsSUFBSSxDQUFDLE9BQU8sRUFDWixJQUFJLENBQUMsaUJBQWlCLENBQ3ZCLENBQUM7QUFDTixRQUNJLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUNyQixZQUFNLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztBQUN4QixTQUFLO0FBQ0wsUUFDSSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdEMsSUFBRSxDQUFDO0FBQ0g7QUFDTztBQUNGO0FBQWdCO0FBQTBCO0FBQzlCO0FBQVEsSUFEZixNQUFNLENBQUMsT0FBc0I7QUFBSSxRQUN2QyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUU7QUFDbEMsWUFBTSxPQUFPO0FBQ2IsU0FBSztBQUNMLFFBQ0ksSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksTUFBTSxJQUFJLE9BQU8sRUFBRTtBQUMxQyxZQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUN6QixTQUFLO0FBQUMsYUFBSyxJQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLE9BQU8sRUFBRTtBQUNoRCxZQUFNLENBQUMsbUJBQThCLElBQUksQ0FBQyxLQUFLLEVBQUEsQ0FBQyxDQUFDLE1BQU0sQ0FDL0MsSUFBSSxDQUFDLElBQUksRUFDVCxJQUFJLENBQUMsT0FBTyxDQUNiLENBQUM7QUFDUixTQUFLO0FBQ0wsSUFBRSxDQUFDO0FBQ0g7QUFDTztBQUNGO0FBQWdCO0FBQ1o7QUFBUSxJQURQLFVBQVU7QUFBSyxRQUNyQixLQUFLLE1BQU0sS0FBSyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFO0FBQ2xELFlBQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUMvQyxTQUFLO0FBQ0wsSUFBRSxDQUFDO0FBQ0g7NkNBNUhDLFNBQVMsU0FBQyxrQkFDVCxRQUFRLEVBQUUsWUFBWSxrQkFDdEIsUUFBUSxFQUFFLEVBQUU7VUFFVixxREFJQyxlQUVKLHVYQUNHO0FBQUM7QUFBbUI7QUFBMkMsWUFqRWpFLFVBQVU7QUFDWDtBQUFHO0FBR0QsbUJBaUVBLEtBQUs7QUFDTixtQkFLQyxLQUFLO0FBQ04sc0JBS0MsS0FBSztBQUNOLGdDQUtDLEtBQUs7QUFDTixxQkFTQyxLQUFLO0FBQ04sMEJBT0MsTUFBTTtBQUNSOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFBQztBQUFhO0FBQVE7QUFHTTtBQUVsQjtBQUNULElBM0NGLGlDQUM2QjtBQUMvQjtBQUVDO0FBQ0U7QUFFQTtBQUFRLElBRFQsaUNBQ2dCO0FBQ2xCO0FBRUM7QUFDRTtBQUVBO0FBQVEsSUFEVCxvQ0FDZ0M7QUFDbEM7QUFFQztBQUNFO0FBRUE7QUFBUSxJQURULDhDQUNxQztBQUN2QztBQUVDO0FBQ0U7QUFDRTtBQUVIO0FBQU87QUFFSjtBQUNNO0FBQVEsSUFEakIsbUNBQ21CO0FBQ3JCO0FBRUM7QUFDRTtBQUNFO0FBRUo7QUFDSztBQUFRLElBRFosd0NBQ2tEO0FBQ3BEO0FBQ087QUFDRjtBQUFpQjtBQUVuQjtBQUFRLElBRlQsa0NBQStCO0FBQ2pDO0FBQ087QUFDQTtBQUFnQjtBQUFRLElBQWpCLHVDQUE4QjtBQUFDO0FBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE91dHB1dCxcbiAgU2ltcGxlQ2hhbmdlc1xufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0ICogYXMgQ2hhcnRpc3QgZnJvbSAnY2hhcnRpc3QnO1xuaW1wb3J0IHsgSUNoYXJ0aXN0QmFzZSwgSUNoYXJ0T3B0aW9ucyB9IGZyb20gJ2NoYXJ0aXN0JztcblxuLyoqXG4gKiBQb3NzaWJsZSBjaGFydCB0eXBlc1xuICovXG5leHBvcnQgdHlwZSBDaGFydFR5cGUgPSAnUGllJyB8ICdCYXInIHwgJ0xpbmUnO1xuXG5leHBvcnQgdHlwZSBDaGFydEludGVyZmFjZXMgPVxuICB8IENoYXJ0aXN0LklDaGFydGlzdFBpZUNoYXJ0XG4gIHwgQ2hhcnRpc3QuSUNoYXJ0aXN0QmFyQ2hhcnRcbiAgfCBDaGFydGlzdC5JQ2hhcnRpc3RMaW5lQ2hhcnQ7XG5leHBvcnQgdHlwZSBDaGFydE9wdGlvbnMgPVxuICB8IENoYXJ0aXN0LklCYXJDaGFydE9wdGlvbnNcbiAgfCBDaGFydGlzdC5JTGluZUNoYXJ0T3B0aW9uc1xuICB8IENoYXJ0aXN0LklQaWVDaGFydE9wdGlvbnM7XG5leHBvcnQgdHlwZSBSZXNwb25zaXZlT3B0aW9uVHVwbGUgPSBDaGFydGlzdC5JUmVzcG9uc2l2ZU9wdGlvblR1cGxlPFxuICBDaGFydE9wdGlvbnNcbj47XG5leHBvcnQgdHlwZSBSZXNwb25zaXZlT3B0aW9ucyA9IFJlc3BvbnNpdmVPcHRpb25UdXBsZVtdO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgY2hhcnQgZXZlbnRzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENoYXJ0RXZlbnQge1xuICBbZXZlbnROYW1lOiBzdHJpbmddOiAoZGF0YTogYW55KSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIEFuZ3VsYXIgY29tcG9uZW50IHdoaWNoIHJlbmRlcnMgQ2hhcnRpc3QgY2hhcnQuXG4gKlxuICogU2VlIENoYXJ0aXN0IHtAbGluayBodHRwczovL2dpb25rdW56LmdpdGh1Yi5pby9jaGFydGlzdC1qcy9hcGktZG9jdW1lbnRhdGlvbi5odG1sIEFQSSBkb2N1bWVudGF0aW9ufSBhbmRcbiAqIHtAbGluayBodHRwczovL2dpb25rdW56LmdpdGh1Yi5pby9jaGFydGlzdC1qcy9leGFtcGxlcy5odG1sIGV4YW1wbGVzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqICMjIyBFeGFtcGxlXG4gYGBgaHRtbFxuIDx4LWNoYXJ0aXN0XG4gICBbdHlwZV09XCJ0eXBlXCJcbiAgIFtkYXRhXT1cImRhdGFcIlxuICAgW29wdGlvbnNdPVwib3B0aW9uc1wiXG4gICBbcmVzcG9uc2l2ZU9wdGlvbnNdPVwicmVzcG9uc2l2ZU9wdGlvbnNcIlxuICAgW2V2ZW50c109XCJldmVudHNcIlxuID48L3gtY2hhcnRpc3Q+XG4gYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3gtY2hhcnRpc3QnLFxuICB0ZW1wbGF0ZTogJycsXG4gIHN0eWxlczogW1xuICAgIGBcbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICB9XG4gICAgYFxuICBdXG59KVxuZXhwb3J0IGNsYXNzIENoYXJ0aXN0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gIC8qKlxuICAgKiBUaGUgZGF0YSBvYmplY3QgdGhhdCBuZWVkcyB0byBjb25zaXN0IG9mIGEgbGFiZWxzIGFuZCBhIHNlcmllcyBhcnJheS5cbiAgICovXG4gIEBJbnB1dCgpXG4gIGRhdGE6IENoYXJ0aXN0LklDaGFydGlzdERhdGE7XG5cbiAgLyoqXG4gICAqIENoYXJ0aXN0IGNoYXJ0IHR5cGUuXG4gICAqL1xuICBASW5wdXQoKVxuICB0eXBlOiBDaGFydFR5cGU7XG5cbiAgLyoqXG4gICAqIFRoZSBvcHRpb25zIG9iamVjdCB3aGljaCBvdmVycmlkZXMgdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAgICovXG4gIEBJbnB1dCgpXG4gIG9wdGlvbnM6IENoYXJ0aXN0LklDaGFydE9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIHJlc3BvbnNpdmUgb3B0aW9uIGFycmF5cyB3aGljaCBhcmUgYSBtZWRpYSBxdWVyeSBhbmQgb3B0aW9ucyBvYmplY3QgcGFpcjogW1ttZWRpYVF1ZXJ5U3RyaW5nLCBvcHRpb25zT2JqZWN0XSxbbW9yZS4uLl1dXG4gICAqL1xuICBASW5wdXQoKVxuICByZXNwb25zaXZlT3B0aW9uczogUmVzcG9uc2l2ZU9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIEV2ZW50cyBvYmplY3Qgd2hlcmUga2V5cyBhcmUgQ2hhcnRpc3QgZXZlbnQgbmFtZXMgYW5kIHZhbHVlcyBhcmUgZXZlbnQgaGFuZGxlciBmdW5jdGlvbnMuXG4gICAqXG4gICAqIFN1cHBvcnRlZCBldmVudHMgYXJlOiBkcmF3LCBvcHRpb25zQ2hhbmdlZCwgZGF0YSwgYW5pbWF0aW9uQmVnaW4sIGFuaW1hdGlvbkVuZCwgY3JlYXRlZC5cbiAgICpcbiAgICogRXZlbnQgaGFuZGxlciBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgYSBkYXRhIGFyZ3VtZW50IHdoaWNoIGNvbnRhaW5zIGV2ZW50IGRhdGEuXG4gICAqL1xuICBASW5wdXQoKVxuICBldmVudHM6IENoYXJ0RXZlbnQ7XG5cbiAgLyoqXG4gICAqIEV2ZW50IGVtaXR0ZWQgYWZ0ZXIgQ2hhcnRpc3QgY2hhcnQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAqXG4gICAqIEV2ZW50IGhhbmRsZXIgZnVuY3Rpb24gd2lsbCByZWNlaXZlIGNoYXJ0IGluc3RhbmNlIGFyZ3VtZW50LlxuICAgKi9cbiAgQE91dHB1dCgpXG4gIGluaXRpYWxpemVkID0gbmV3IEV2ZW50RW1pdHRlcjxDaGFydEludGVyZmFjZXM+KCk7XG5cbiAgLyoqIEBpZ25vcmUgKi9cbiAgcHJpdmF0ZSBjaGFydDogQ2hhcnRJbnRlcmZhY2VzO1xuXG4gIC8qKiBAaWdub3JlICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZikge31cblxuICAvKiogQGlnbm9yZSAqL1xuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy50eXBlICYmIHRoaXMuZGF0YSkge1xuICAgICAgdGhpcy5yZW5kZXJDaGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaWdub3JlICovXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICB0aGlzLnVwZGF0ZShjaGFuZ2VzKTtcbiAgfVxuXG4gIC8qKiBAaWdub3JlICovXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNoYXJ0KSB7XG4gICAgICB0aGlzLmNoYXJ0LmRldGFjaCgpO1xuICAgICAgdGhpcy5jaGFydCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpZ25vcmUgKi9cbiAgcHJpdmF0ZSByZW5kZXJDaGFydCgpIHtcbiAgICBjb25zdCBuYXRpdmVFbGVtZW50ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICBpZiAoISh0aGlzLnR5cGUgaW4gQ2hhcnRpc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy50eXBlfSBpcyBub3QgYSB2YWxpZCBjaGFydCB0eXBlYCk7XG4gICAgfVxuXG4gICAgdGhpcy5jaGFydCA9ICg8YW55PkNoYXJ0aXN0KVt0aGlzLnR5cGVdKFxuICAgICAgbmF0aXZlRWxlbWVudCxcbiAgICAgIHRoaXMuZGF0YSxcbiAgICAgIHRoaXMub3B0aW9ucyxcbiAgICAgIHRoaXMucmVzcG9uc2l2ZU9wdGlvbnNcbiAgICApO1xuXG4gICAgaWYgKHRoaXMuZXZlbnRzKSB7XG4gICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRpYWxpemVkLmVtaXQodGhpcy5jaGFydCk7XG4gIH1cblxuICAvKiogQGlnbm9yZSAqL1xuICBwcml2YXRlIHVwZGF0ZShjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnR5cGUgfHwgIXRoaXMuZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jaGFydCB8fCAndHlwZScgaW4gY2hhbmdlcykge1xuICAgICAgdGhpcy5yZW5kZXJDaGFydCgpO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlcy5kYXRhIHx8IGNoYW5nZXMub3B0aW9ucykge1xuICAgICAgKDxJQ2hhcnRpc3RCYXNlPElDaGFydE9wdGlvbnM+PnRoaXMuY2hhcnQpLnVwZGF0ZShcbiAgICAgICAgdGhpcy5kYXRhLFxuICAgICAgICB0aGlzLm9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpZ25vcmUgKi9cbiAgcHJpdmF0ZSBiaW5kRXZlbnRzKCk6IHZvaWQge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXModGhpcy5ldmVudHMpKSB7XG4gICAgICB0aGlzLmNoYXJ0Lm9uKGV2ZW50LCB0aGlzLmV2ZW50c1tldmVudF0pO1xuICAgIH1cbiAgfVxufVxuIl19